---
title: "Unifying individual differences in personality, predictability, and plasticity: a practical guide - 'brms' model code"
author: Rose E. Oâ€™Dea, Daniel W.A. Noble, Shinichi Nakagawa
date: "`r Sys.Date()`"
output: 
  bookdown::html_document2:
    code_folding: hide
    number_sections: no
    toc: yes
    toc_depth: 6
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, tidy = TRUE)
options(digits=2)
```

```{r klippy, echo=FALSE, include=TRUE, message=FALSE, warning=FALSE}
#install.packages("devtools")
#remotes::install_github("rlesur/klippy")
klippy::klippy(tooltip_message = 'Click to Copy Code', tooltip_success = 'Done', position = 'right', color = "red")
```

# Introduction

This supplement introduces readers to the calculations and modelling approaches, reviewed by:\
Rose E. O'Dea, Daniel W.A. Noble and Shinichi Nakagawa 2021. *Unifying individual differences in personality, predictability, and plasticity: a practical guide*, using the `brms` R package (which interfaces with `stan`).

We only fit an exemplar set of models from our worked example. More specifically, we focus on a subset of models using two traits (aggression and activity) to demonstrate how to fit single- and double- hierarchical generalized linear models (abbreviated as SHGLM and DHGLM, respectively). This includes uni-variate and bi-variate (two trait) models. For a selection of models we also show how to: 1) calculate repeatability and the coefficient of variation for the mean and dispersion models, and 2) extract and manipulate individual BLUPs (best linear unbiased predictors) to estimate between-individual correlations outlined in our manuscript.

# R Packages, Data and Model Fits
Readers will need to download the data and model fits (unless they want to rerun the models) from our [Open Science Framework (OSF) Project Site](http://doi.org/10.17605/OSF.IO/V3QAX). Once downloaded and placed in your working directory run the following code to load the data sets and R packages:

```{r loadpackages, echo = TRUE, results = "hide", messages = FALSE, class.source='klippy'}
# install.packages("pacman")
# Load Libraries and relevant data
		pacman::p_load(klippy, brms, dplyr, here, flextable)	

		
# Get the raw data. We need this for back transformation from z-scale
		# making sure fish_ID is coded as a factor (done automatically before R v4+)
		# square-root transforming novel and predator response variables
		# z-scaling all variables
		
	  dat <- read.csv("./Data/data_predictability_worked_example.csv")
		
	  dat <- dat %>% 
	         dplyr::mutate(fish_ID = factor(fish_ID, levels = unique(fish_ID)),
		                       age.Z = scale(age_days),
		                    activity = scale(dist_m_Activity),
		                  aggression = scale(stim.dist_0_5cm_dur_Aggression),
		                       novel = scale(sqrt(stim.dist_0_10cm_dur_Novel)),     
		                    predator = scale(sqrt(stim.dist_0_10cm_dur_Predator)), 
		                      social = scale(stim.dist_0_5cm_dur_Social),
		                      id = fish_ID)	

# processed Stan models for comparison
load("./Results/stanmodels_processed.Rdata")
stanproc_personality_shglm_aggression <- stanmods[stanmods$model=="personality shglm" & stanmods$behaviour1=="aggression",]
stanproc_personality_dhglm_aggression <- stanmods[stanmods$model=="personality dhglm" & stanmods$behaviour1=="aggression",]
stanproc_personality_plasticity_shglm_aggression <- stanmods[stanmods$model=="personality & plasticity shglm" & stanmods$behaviour1=="aggression",]
stanproc_personality_plasticity_dhglm_aggression <- stanmods[stanmods$model=="personality & plasticity dhglm" & stanmods$behaviour1=="aggression",]
stanproc_bivar_shglm_activity_aggression <- stanmods[stanmods$model=="bivariate shglm" & stanmods$behaviour1=="activity" & stanmods$behaviour2=="aggression",]
stanproc_bivar_dhglm_activity_aggression <- stanmods[stanmods$model=="bivariate dhglm" & stanmods$behaviour1=="activity" & stanmods$behaviour2=="aggression",]
	  
```

# Load Functions

Load in the functions that will be needed to process output from the models to derive the various estimates needed for calculating the necessary parameters:

```{r funcs, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}

  # Population-level intercept   
		func_Bp <- function(B0, B1){
		  Bp <- (2*B0 + B1)/2 # assumes 50/50 ratio for B1 (in our example = sex)
		  return(Bp)
		}

   # Total variance, equation 40. Function for summing dataframe of variance components 
		func_sum_var <- function(vars){
		  sum_var <- sapply(1:nrow(vars), function(x) sum(vars[x,], na.rm = T))
		  return(sum_var)
		}


		# Variance for fixed effects
		func_var_fixed <- function(B1, B2, data){
		  # model matrix for fixed effects
		  X <- model.matrix(~ 1 + sex + age.Z, data = data) 
    		  X1 <- X[,2]
    		  X2 <- X[,3]
		  var_fixed <- sapply(1:length(B1), function(x) var(X1*B1[x] + X2*B2[x]))
		  return(var_fixed)
		}		
		
		 # within-individual standard deviation
		 	 func_var_within <- function(Bpv, sigma_v0, var_fixed_v){
		 	   
		 	   # summed variance components
		 	   var_within_exp <- func_sum_var(vars = data.frame(sigma_v0^2, var_fixed_v))
		 	   # conversion back from log scale
		 	   var_within <- func_ln_convert(mu_ln = Bpv, sigma_ln = sqrt(var_within_exp))$mu_raw
		 	   
		 	   return(var_within)
		 	 }
		 	 
		 	  # Repeatability for the dispersion model for DHGLM    
		 	 func_Rp_var <- function(Bpv, sigma_v0, var_fixed_v, var_p){
		 	   
		 	   # sum of IDv0 and fixedV = total variance in residual variance on log-normal scale:
		 	   var_residvar_exp <- func_sum_var(vars = data.frame(sigma_v0^2, var_fixed_v))
		 	   # converting back to same scale as mean model: 
		 	   sigma_residvar <- func_ln_convert(mu_ln = Bpv, sigma_ln = sqrt(var_residvar_exp))$sigma_raw
		 	   
		 	   # variance in phenotypic variance
		 	   total_var_var <- 2*var_p^2 + 3*sigma_residvar^2
		 	   
		 	   # getting variance in individual component through the preservation of the proportionality (i.e. ratio method)
		 	   ratio <- sigma_v0^2/(var_residvar_exp)
		 	   var_ID <- sigma_residvar^2*ratio
		 	   
		 	   Rp_var <- var_ID/total_var_var
		 	   return(Rp_var)
		 	 }
		
		 	 # Convert from ln to raw scale
		 func_ln_convert <- function(mu_ln, sigma_ln){
  
        mu_raw <- exp(mu_ln + sigma_ln^2/2)
        var_raw <- (exp(sigma_ln^2)-1)*exp(2*mu_ln + sigma_ln^2)
        
        x <- data.frame(mu_raw, sigma_raw = sqrt(var_raw))
        return(x)
		 }	 
		 
		 
		# Function takes random slopes and intercepts and calculates the between individual correlation between them and returns this correlation for each row (i.e., posterior sampling iteration). It returns a posterior distribution of the correlation. 
		 
	 cor_calc <- function(slopes, intercepts){
          cors <- c()
          for(i in 1:dim(intercepts)[1]){
                cors <- c(cors, cor(as.numeric(slopes[i,]),as.numeric(intercepts[i,])))
          }
          return(cors)
      }
      
		 	 
```

# Running *brms* SHGLM and DHGLM models {.tabset}

## Personality (SHGLM) {#personality-shglm .tabset .tabset-fade .tabset-pills}
### Model {.tabset .tabset-fade .tabset-pills}

Let's start by fitting a model to the aggression data to estimate "personality".

```{r personality, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
########### Personality ##########
# EXAMPLE 1: standata_personality_shglm_aggression; replicates the following model
#  stan_personality_shglm_aggression <- stan(file = "./Code/stancode_personality_shglm.stan",
#                                          data = standata_personality_shglm_aggression,
#                                          pars = save_pars, 
#                                          iter = 6000, warmup = 2000, chains = 3, cores = 3)
##################################  

	# Fit a model for aggression that includes fixed effects of sex and z-transformed age plus a random intercept for individual ID
		rerun1 = FALSE
		
		if(rerun1) {
		        formula_personality_shglm_aggression <- bf(aggression ~ sex + age.Z + (1 | id))
			brms_personality_shglm_aggression <- brms::brm(formula_personality_shglm_aggression, data = dat, 
									iter = 6000, warmup = 2000, chains = 3, cores = 3, 
									save_pars = save_pars())
			saveRDS(brms_personality_shglm_aggression, "./Models/brms_models/brms_personality_shglm_aggression") 
		} else {
			brms_personality_shglm_aggression <- readRDS(here::here("Models/brms_models","brms_personality_shglm_aggression"))
		}
		
		summary(brms_personality_shglm_aggression)
```

### Calculate CVm and Rpm {.tabset .tabset-fade .tabset-pills}

We demonstrate the calculation of the coefficient of variation ($CV_m$) and repeatability ($Rp_m$) of the mean from our SHGLM. We compare the results to the `stan` model results (i.e., `stanproc_`) from our worked example.

```{r pers_rpm_cv, include=TRUE, results = "hide",  message=FALSE, warning=FALSE, class.source='klippy'}
# (Step 1):  Get the average intercept from fixed effects.
    Bpm <- func_Bp(B0 = brms::posterior_samples(brms_personality_shglm_aggression, pars = "Intercept")[,1], 
                   B1 = brms::posterior_samples(brms_personality_shglm_aggression, pars = "sex")[,1])
      mean(Bpm)
      mean(stanproc_personality_shglm_aggression$B1_pm)

# (Step 2): Extract random intercept for ID. Numerator for eqn 34. Note these are standard deviations for between-individual differences in the mean model
		sigma_m0 <- brms::posterior_samples(brms_personality_shglm_aggression, pars = "sd_id__Intercept")[,1]
		mean(sigma_m0)
    mean(stanproc_personality_shglm_aggression$sigma_ID1_m0)

# (Step 3): Extract residual standard deviation
		 sigma_e <- brms::posterior_samples(brms_personality_shglm_aggression, pars = "sigma")[,1]
		 mean(sigma_e)
		 mean(stanproc_personality_shglm_aggression$sigma_e1)
		
# (Step 4): Calculate fixed effect variance
	var_fixed <- func_var_fixed(B1 =  brms::posterior_samples(brms_personality_shglm_aggression, pars = "sex")[,1],
		                          B2 =  brms::posterior_samples(brms_personality_shglm_aggression, pars = "age.Z")[,1],
		                          data = dat) 
	mean(var_fixed)
	mean(stanproc_personality_shglm_aggression$var1_fixed_m)

# (Step 5): Calculate total phenotypic variance
		total_var <- func_sum_var(vars = data.frame(sigma_m0^2, var_fixed, sigma_e^2))
		mean(total_var)
		mean(stanproc_personality_shglm_aggression$var1_p)
		
# (Step 6): Convert back from z-scale 
		mu_unscaled <- mean(dat$stim.dist_0_5cm_dur_Aggression)
		sigma_unscaled <- sd(dat$stim.dist_0_5cm_dur_Aggression)
		
		         Mu <- Bpm*sigma_unscaled + mu_unscaled
	         	 Sigma <- sqrt(total_var)*sigma_unscaled
		
    indiv_sd <- sqrt(sigma_m0^2)*sigma_unscaled

# (Step 7): Calculate CVm 
		CV_m <- indiv_sd/Mu
		mean(CV_m)
		mean(stanproc_personality_shglm_aggression$CV1_mu)

# (Step 8): Calculate Rpm		
		Rp_m <- sigma_m0^2/total_var
		mean(Rp_m)
		mean(stanproc_personality_shglm_aggression$Rp1_mu)


```

```{r, message=FALSE, warning=FALSE, class.source='klippy'}
# Results
			personality_results <- data.frame( CVm = mean(CV_m),
			                                   CVm.L = quantile(CV_m, 0.025),
			                                   CVm.U = quantile(CV_m, 0.975),
			                                   	Rpm =  mean(Rp_m),
			                                   Rpm.L = 	quantile(Rp_m, 0.025),
			                                   Rpm.U = 	quantile(Rp_m, 0.975))
			flextable::flextable(personality_results) %>% 
			flextable::compose(part = "header", j = c(1:6), value = c(as_paragraph("CV", as_sub("m")),
																																as_paragraph("95% CI", as_sub("lower")),
																																as_paragraph("95% CI", as_sub("upper")),
																																as_paragraph("Rp", as_sub("m")),
																																as_paragraph("95% CI", as_sub("lower")),
																																as_paragraph("95% CI", as_sub("upper"))) ) %>%
			align(align = "center", part = "header") %>%  fit_to_width(max_width = 7)
		
```
## Personality / Predictability (DHGLM) {#personality-predictability-dhglm .tabset .tabset-fade .tabset-pills}
### Model {.tabset .tabset-fade .tabset-pills}

Let's start by fitting a model to the aggression data to estimate both "personality" (mean model) and "predictability" (dispersion model).

```{r personality_pred, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
####### Personality / Predictability ##########
# EXAMPLE 2: standata_personality_dhglm_aggression; replicates the following model
# stan_personality_dhglm_aggression <- stan(file = "./Code/stancode_personality_dhglm.stan",
#                                          data = standata_personality_dhglm_aggression,
#                                          pars = save_pars, 
#                                          iter = 6000, warmup = 2000, chains = 3, cores = 3)	
###############################################   	

	rerun2=FALSE
	
	if(rerun2){
	    formula_personality_dhglm_aggression <- bf(aggression ~ sex + age.Z + (1 | p | id),
	    			            sigma ~ sex + age.Z + (1 | p | id)) 

		brms_personality_dhglm_aggression <- brm(formula_personality_dhglm_aggression, data = dat, 
								iter = 6000, warmup = 2000, chains = 3, cores = 3, 
								save_pars = save_pars()) 
		
		saveRDS(brms_personality_dhglm_aggression, "./Models/brms_models/brms_personality_dhglm_aggression")
	} else {
		brms_personality_dhglm_aggression <- readRDS(here::here("Models/brms_models", "brms_personality_dhglm_aggression"))
	}

	summary(brms_personality_dhglm_aggression)
```

### Calculate CVm and Rpm {.tabset .tabset-fade .tabset-pills}

Here we now have two separate models: a mean model and a dispersion model.

```{r personality_pred_cvm_rpm, results = "hide", include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
#################################
# Mean and Dispersion Parameters
#################################
 
  # (Step 1): Extract the population coefficients for mean model
		 	 B0_m <- brms::posterior_samples(brms_personality_dhglm_aggression, pars = "b_Intercept")[,1]			 
		 	 B1_m <- brms::posterior_samples(brms_personality_dhglm_aggression, pars = "b_sex")[,1]	
		 	 B2_m <- brms::posterior_samples(brms_personality_dhglm_aggression, pars = "b_age.Z")[,1]	
		 	 
		 	 mean(B0_m)
		 	 mean(stanproc_personality_dhglm_aggression$B1_m0)
		 	 
		 	 mean(B1_m)
		 	 mean(stanproc_personality_dhglm_aggression$B1_m1)
		 	 
		 	 mean(B2_m)
		 	 mean(stanproc_personality_dhglm_aggression$B1_m2)
	
	# (Step 2): Extract the population coefficients for dispersion model	 
		 	 B0_sd_exp <- brms::posterior_samples(brms_personality_dhglm_aggression, pars = "b_sigma_Intercept")[,1]			
		 	 B1_sd_exp <- brms::posterior_samples(brms_personality_dhglm_aggression, pars = "b_sigma_sex")[,1]	
		 	 B2_sd_exp <- brms::posterior_samples(brms_personality_dhglm_aggression, pars = "b_sigma_age.Z")[,1]
		 	 
		 	 # for comparison between ln(var) and ln(sd) models, need to multiple ln(sd) by 2
		 	 mean(2*B0_sd_exp)
		 	 mean(stanproc_personality_dhglm_aggression$B1_v0)
		 	 
		 	 mean(2*B1_sd_exp)
		 	 mean(stanproc_personality_dhglm_aggression$B1_v1)
		 	 
		 	 mean(2*B2_sd_exp)
		 	 mean(stanproc_personality_dhglm_aggression$B1_v2)
		 	 
	# (Step 3): Extract the random ID intercept variance components for random intercept. Note that we model ln(sd) so we need to convert to variance scale by multipling by 2.
		 	  sigma_ID_m0 <- brms::posterior_samples(brms_personality_dhglm_aggression, pars = "sd_id__Intercept")[,1]
		 	  sigma_ID_sd0 <- brms::posterior_samples(brms_personality_dhglm_aggression, 
		 	                                         pars = "sd_id__sigma_Intercept")[,1]
		 	  sigma_ID_v0 <- 2*sigma_ID_sd0
		 	  
		 	  mean(sigma_ID_v0)
		 	  mean(stanproc_personality_dhglm_aggression$sigma_ID1_v0)
		 	 
	
	# (Step 4): Calculate the fixed effect variance for the mean model (var_fixed_m) and the dispersion model (B_pv)
		 	 B_pm <- func_Bp(B0 = B0_m, B1 = B1_m)
		 	 B_pv <- 2*func_Bp(B0 = B0_sd_exp, B1 = B1_sd_exp)
		 	 
		 	 mean(B_pm)
		 	 mean(stanproc_personality_dhglm_aggression$B1_pm)
		 	 
		 	 mean(B_pv)
		 	 mean(stanproc_personality_dhglm_aggression$B1_pv)
		 	 
  # (Step 5): Calculate the population intercept for the mean model (var_fixed_m) and dispersion model (var_fixed_v). Note that a variance on the ln(sd) scale can be converted to a ln(var) by multipling by 4. See supplemental text.
		 	 var_fixed_m <- func_var_fixed(B1 = B1_m, B2 = B2_m, data = dat)
		 	 var_fixed_v <- 4*func_var_fixed(B1 = B1_sd_exp, B2 = B2_sd_exp, data = dat)
		 	 
		 	 mean(var_fixed_m)
		 	 mean(stanproc_personality_dhglm_aggression$var1_fixed_m)
		 	 
		 	 mean(var_fixed_v)
		 	 mean(stanproc_personality_dhglm_aggression$var1_fixed_v)

###################################
# Mean Model - Repeatability and CV
###################################

	  # (Step 1): Calculate average within-individual / residual variance
		 	 sigma_w <- func_var_within(Bpv = B_pv, 
		 	                            sigma_v0 = sigma_ID_v0, 
		 	                            var_fixed_v = var_fixed_v)
		 	 
		 	 mean(sigma_w)
		 	 mean(stanproc_personality_dhglm_aggression$sigma1_w)
		 	 
		# (Step 2): Calculate total phenotypic variance 
		 	 var_p <- func_sum_var(vars = data.frame(sigma_ID_m0^2, var_fixed_m, sigma_w^2))
		 	 
		 	 mean(var_p)
		 	 mean(stanproc_personality_dhglm_aggression$var1_p)
		 	 
		# (Step 3): Calculate repeatability
		 	 Rp_mu <- sigma_ID_m0^2/var_p
		 	 
		 	 mean(Rp_mu)
		 	 mean(stanproc_personality_dhglm_aggression$Rp1_mu)
		 	 
		# (Step 4): Convert back from z-scale to calculate CVm
		 	       mu_unscaled <- mean(dat$stim.dist_0_5cm_dur_Aggression)
		 	    sigma_unscaled <-   sd(dat$stim.dist_0_5cm_dur_Aggression)
		 	 
		 	       Mu <- B_pm*sigma_unscaled + mu_unscaled
		 	    Sigma <- sqrt(var_p)*sigma_unscaled
		 	 indiv_sd <- sigma_ID_m0*sigma_unscaled
		
		# (Step 5): Calculate CVm for mean model
		 	 CV_mu <- indiv_sd/Mu
		 	 
		 	 mean(CV_mu)
		 	 mean(stanproc_personality_dhglm_aggression$CV1_mu)
		 	 
###################################
# Dispersion Model - Repeatability and CV
###################################
		 	
		# (Step 1): Calculate repeatability for the dispersion model
		 	 Rp_var <- func_Rp_var(Bpv = B_pv, 
		 	                       sigma_v0 = sigma_ID_v0, 
		 	                       var_fixed_v = var_fixed_v, 
		 	                       var_p = var_p)
		 	 
		 	 mean(Rp_var)
		 	 mean(stanproc_personality_dhglm_aggression$Rp1_var)
		 	
		# (Step 2): Sum of IDv0 and fixedV = total variance in residual variance on log-normal scale
		 	   var_residvar_exp <- func_sum_var(vars = data.frame(sigma_ID_v0^2, var_fixed_v))
		 
		 	   
    # (Step 3): Converting back to same scale as mean model  
		 	   sigma_residvar <- func_ln_convert(mu_ln = B_pv, 
		 	                                     sigma_ln = sqrt(var_residvar_exp))$sigma_raw
		 	   
		# (Step 4): Getting variance in individual component through the preservation of the proportionality (i.e. ratio method)
		 	    ratio <- sigma_ID_v0^2/(var_residvar_exp)
		 	   var_ID <- sigma_residvar^2*ratio
		
	  # (Step 5): Calculate coefficient of variation 
		 	   CV_var <- sqrt(var_ID)/sigma_w^2   
		 	   
		 	   mean(CV_var)
		 	   mean(stanproc_personality_dhglm_aggression$CV1_var)
```

```{r personality_pred_results, echo = FALSE, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}

pers_pred_results <- data.frame(model = c("Mean Model", "", "Dispersion Model", ""),
                                 type = c("Rpm", "CVm", "Rp_var", "CV_var"),
                                Est = c(mean(Rp_mu), mean(CV_mu), mean(Rp_var), mean(CV_var)),
                                L.CI= c(quantile(Rp_mu,0.025), quantile(CV_mu,0.025), quantile(Rp_var,0.025),quantile(CV_var,0.025)), 
                                U.CI= c(quantile(Rp_mu,0.975), quantile(CV_mu,0.975), quantile(Rp_var,0.975),quantile(CV_var,0.975)))
flextable::flextable(pers_pred_results) %>%
flextable::compose(part = "header", j = c(1:5), value = c(as_paragraph("Model"),
																													as_paragraph("Estimate Type"),
																													as_paragraph("Mean Estimate"),
																													as_paragraph("95% CI", as_sub("lower")),
																													as_paragraph("95% CI", as_sub("upper")) )) %>%
flextable::compose(part = "body", i = c(1:4), j = 2, value = c(as_paragraph("Rp", as_sub("m")),
																																as_paragraph("CV", as_sub("m")),
																																as_paragraph("Rp", as_sub("v")),
																																as_paragraph("CV", as_sub("v")) )) %>%	
		align(align = "center", part = "header") %>% 	fit_to_width(max_width = 7)
```


## Personality & Plasticity (SHGLM - Random Slope) {.tabset .tabset-fade .tabset-pills}
### Model {.tabset .tabset-fade .tabset-pills}

Here, using a random regression model, we can estimate a random intercept and slope along with the correlation between the intercept and slopes. The correlation between intercept and slope at the individual level is estimated directly from the model but we can also store BLUPs (`save_pars = save_pars()`) and processes these after fitting the model to estimate the correlations described within our paper.

```{r personality_plas, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}

########### Personality / Plasticity ##############
#stan_personality_plasticity_shglm_aggression; replicates the following model
#stan_personality_plasticity_shglm_aggression <- stan(file = "./Code/stancode_personality_plasticity_shglm.stan",
#                                                     data = standata_personality_plasticity_shglm_aggression,
#                                                     pars = save_pars, 
#                                                     iter = 6000, warmup = 2000, chains = 3, cores = 3)   
###################################################
	rerun3 = FALSE

	if(rerun3){
		    formula_stan_personality_plasticity_shglm_aggression <- bf(  aggression ~ sex + age.Z + (1 + age.Z | p | id))

		brms_personality_plasticity_shglm_aggression <- brm(formula_stan_personality_plasticity_shglm_aggression, data = dat, 
								iter = 6000, warmup = 2000, chains = 3, cores = 3, 
								save_pars = save_pars()) 
		saveRDS(brms_personality_plasticity_shglm_aggression, "./Models/brms_models/brms_personality_plasticity_shglm_aggression")
	} else {
		brms_personality_plasticity_shglm_aggression <- readRDS(here::here("Models/brms_models", "brms_personality_plasticity_shglm_aggression"))
	}

	summary(brms_personality_plasticity_shglm_aggression)
```

### Personality-Plasticity Associations {.tabset .tabset-fade .tabset-pills}

Here, using the model we can calculate the personality-plasticity association (i.e., the correlation between individual intercepts and either slope differences, or slope magnitudes).

```{r pers_plas, include=TRUE, results = "hide", message=FALSE, warning=FALSE, class.source='klippy'}
# Equation 8: correlation between intercept and slope deviations

cor_slope_dif <- brms::posterior_samples(brms_personality_plasticity_shglm_aggression, pars = "cor_id__Intercept__age.Z", fixed = TRUE)[,1]

mean(cor_slope_dif)
mean(stanproc_personality_plasticity_shglm_aggression$cor_ID1_m0_ID1_m2)

# Correlation between intercept differences and slope magnitudes: Equation 9     
      # Extract blups
       blups_IDm0 <- brms::posterior_samples(brms_personality_plasticity_shglm_aggression, pars = "r_id[[1-9].*,Intercept]")
       blups_IDm2 <- brms::posterior_samples(brms_personality_plasticity_shglm_aggression, pars = "r_id[[1-9].*,age.Z]")
       Bm2 <- brms::posterior_samples(brms_personality_plasticity_shglm_aggression, pars = "b_age.Z", fixed = TRUE)[,1]
      
      # Calculate the absolute magnitude of individuals slope and each individuals slope deviation (Eqn. 9 of main manuscript)
        abs_slope <- apply(blups_IDm2, 2, function(x) abs(Bm2 + x))
      
      # Using absolute slope and the individual deviations for each individuals intercept calculate the correlation across the 248 fish for each posterior sample of individual blups
        cor_slope_mag <- cor_calc(slopes = abs_slope, intercepts = blups_IDm0)
       
      # Check that we have 12,000 samples from posterior
        length(cor_slope_mag)
      
      # Estimate the mean and 95% CI  
         mean(cor_slope_mag)
         quantile(cor_slope_mag, c(0.025, 0.975))
         mean(stanproc_personality_plasticity_shglm_aggression$personality_plasticity_association1)
         quantile(stanproc_personality_plasticity_shglm_aggression$personality_plasticity_association1, c(0.025, 0.975))
            
```

We can have a look at the posterior distributions of our correlaton estimates for the two different types. 

```{r, include=TRUE, class.source='klippy'}
      # Look at distribution of correlation coefficients
       par(mfrow = c(1,2))
        hist(cor_slope_dif, main = "Slope / Intercept Deviations")        
        hist(cor_slope_mag, main = "Slope Magnitudes / Intercept Deviations")
```

## Personality & Predictability & Plasticity (DHGLM - Random Slope) {.tabset .tabset-fade .tabset-pills}
### Model {.tabset .tabset-fade .tabset-pills}

In this section we are modelling a random slope and intercept in the mean model, and a random intercept in the dispersion model. We will also estimate the correlation between slopes and intercepts across the models.

```{r, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
######## Personality/Plasticity/Predictability ###################
#stan_personality_plasticity_dhglm_aggression <- stan(file = "./Code/stancode_personality_plasticity_dhglm.stan",
#                                                     data = standata_personality_plasticity_dhglm_aggression,
#                                                     pars = save_pars, 
#                                                     iter = 6000, warmup = 2000, chains = 3, cores = 3)
##################################################################
	
	rerun4 = FALSE 

	if(rerun4){
	    formula_personality_plasticity_dhglm_aggression <- bf(  aggression ~ sex + age.Z + (1 + age.Z | q | id) ,
	    			                                                       sigma ~ sex + age.Z + (1 | q | id))  
	
		brms_personality_plasticity_dhglm_aggression <- brm(formula_personality_plasticity_dhglm_aggression, data = dat, 
								iter = 6000, warmup = 2000, chains = 3, cores = 3, 
								save_pars = save_pars()) 
		saveRDS(brms_personality_plasticity_dhglm_aggression, "./Models/brms_models/brms_personality_plasticity_dhglm_aggression")
	} else {
		brms_personality_plasticity_dhglm_aggression <- readRDS(here::here("Models/brms_models", "brms_personality_plasticity_dhglm_aggression"))
	}

	summary(brms_personality_plasticity_dhglm_aggression)
```

### Calculate CVm and Rpm from Random Slope Model {.tabset .tabset-fade .tabset-pills}

Random regression for both the mean and dispersion model requires some modifications to calculate repeatability and the coefficient of variation. '\*\*' in the annotated steps below indicate what changes from previous models.

```{r personality_slope_cvm_rpm, results = "hide", include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
#################################
# Mean and Dispersion Parameters
#################################
 
  # (Step 1): Extract the population coefficients for mean model
		 	 B0_m <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "b_Intercept")[,1]			 
		 	 B1_m <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "b_sex")[,1]	
		 	 B2_m <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "b_age.Z")[,1]	
		 	 
		 	 mean(B0_m)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$B1_m0)
		 	 
		 	 mean(B1_m)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$B1_m1)
		 	 
		 	 mean(B2_m)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$B1_m2)
	
	# (Step 2): Extract the population coefficients for dispersion model	 
		 	 B0_sd_exp <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "b_sigma_Intercept")[,1]			
		 	 B1_sd_exp <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "b_sigma_sex")[,1]	
		 	 B2_sd_exp <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "b_sigma_age.Z")[,1]
		 	 
		 	 mean(2*B0_sd_exp)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$B1_v0) 
		 	 
		 	 mean(2*B1_sd_exp)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$B1_v1)
		 	 
		 	 mean(2*B2_sd_exp)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$B1_v2)
		 	 
	# (Step 3): Extract the random ID intercept variance components for random intercept. Note that we model ln(sd) so we need to convert to variance scale by multipling by 2.
		 	  sigma_ID_m0 <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "sd_id__Intercept")[,1]
		 	  
		 	  mean(sigma_ID_m0)
		 	  mean(stanproc_personality_plasticity_dhglm_aggression$sigma_ID1_m0)
		 	  
		 	  sigma_ID_sd0 <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, 
		 	                                         pars = "sd_id__sigma_Intercept")[,1]
		 	  sigma_ID_v0 <- 2*sigma_ID_sd0
		 	  
		 	  mean(sigma_ID_v0)
		 	  mean(stanproc_personality_plasticity_dhglm_aggression$sigma_ID1_v0)
	
	# (Step 4): **New step as we now have a sd for the random slopes.**
	     sigma_ID_m2 <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "sd_id__age.Z")[,1]
	     
	     mean(sigma_ID_m2)
	     mean(stanproc_personality_plasticity_dhglm_aggression$sigma_ID1_m2)
		 	  
	# (Step 5): Calculate the fixed effect variance for the mean model (var_fixed_m) and the dispersion model (B_pv). Note here that the calculations are the same because we assume intercept at an average age.
		 	 B_pm <- func_Bp(B0 = B0_m, B1 = B1_m)
		 	 B_pv <- 2*func_Bp(B0 = B0_sd_exp, B1 = B1_sd_exp)
		 	 
		   mean(B_pm)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$B1_pm)
		 	 
		 	 mean(B_pv)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$B1_pv)
		 	 
	# (Step 6): Calculate the population intercept for the mean model (var_fixed_m) and dispersion model (var_fixed_v). Note that a variance on the ln(sd) scale can be converted to a ln(var) by multipling by 4. See supplemental text.
		 	 var_fixed_m <- func_var_fixed(B1 = B1_m, B2 = B2_m, data = dat)
		 	 var_fixed_v <- 4*func_var_fixed(B1 = B1_sd_exp, B2 = B2_sd_exp, data = dat)
		 	 
		 	 mean(var_fixed_m)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$var1_fixed_m)
		 	 
		 	 mean(var_fixed_v)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$var1_fixed_v)

###################################
# Mean Model - Repeatability and CV
###################################

	  # (Step 1): ** Calculate average within-individual / residual variance **
		 	 sigma_w <- func_var_within(           Bpv = B_pv, 
		 	                                  sigma_v0 = sigma_ID_v0, 
		 	                                  var_fixed_v = var_fixed_v)
		 	 
		 	 mean(sigma_w)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$sigma1_w) 
		 	 
		# (Step 2): Calculate total phenotypic variance. Note here that we add in the random slope variance now
		 	 var_p <- func_sum_var(vars = data.frame(sigma_ID_m0^2, sigma_ID_m2^2, var_fixed_m, sigma_w^2))
		 	 
		 	 mean(var_p)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$var1_p)
		 	 
		# (Step 3): Calculate repeatability
		 	 Rp_mu <- sigma_ID_m0^2/var_p
		 	 
		 	 mean(Rp_mu)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$Rp1_mu)
		 	 
		# (Step 4): Convert back from z-scale to calculate CVm
		 	       mu_unscaled <- mean(dat$stim.dist_0_5cm_dur_Aggression)
		 	    sigma_unscaled <-   sd(dat$stim.dist_0_5cm_dur_Aggression)
		 	 
		 	       Mu <- B_pm*sigma_unscaled + mu_unscaled
		 	    Sigma <- sqrt(var_p)*sigma_unscaled
		 	 indiv_sd <- sigma_ID_m0*sigma_unscaled
		
		# (Step 5): Calculate CVm for mean model
		 	 CV_mu <- indiv_sd/Mu
		 	 
		 	 mean(CV_mu)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$CV1_mu)
		 	 
###################################
# Dispersion Model - Repeatability and CV
###################################
		 	
		# (Step 1): Calculate repeatability for the dispersion model
		 	 Rp_var <- func_Rp_var(Bpv = B_pv, 
		 	                       sigma_v0 = sigma_ID_v0, 
		 	                       var_fixed_v = var_fixed_v, 
		 	                       var_p = var_p)
		 	 
		 	 mean(Rp_var)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$Rp1_var)
		 	
		# (Step 2): ** Sum of IDv0 (intercept), and fixedV = total variance in residual variance on log-normal scale. See eqn 39. in MS.** 
		 	   var_residvar_exp <- func_sum_var(vars = data.frame(sigma_ID_v0^2, var_fixed_v)) 
		 	   
    # (Step 3): Converting back to same scale as mean model  
		 	   sigma_residvar <- func_ln_convert(mu_ln = B_pv, 
		 	                                     sigma_ln = sqrt(var_residvar_exp))$sigma_raw
		 	   
		# (Step 4): Getting variance in individual component through the preservation of the proportionality (i.e. ratio method)
		 	    ratio <- sigma_ID_v0^2/(var_residvar_exp)
		 	   var_ID <- sigma_residvar^2*ratio
		
	  # (Step 5): Calculate coefficient of variation 
		 	   CV_var <- sqrt(var_ID)/sigma_w^2   
		 	   
		 	 mean(CV_var)
		 	 mean(stanproc_personality_plasticity_dhglm_aggression$CV1_var)

```

```{r personality_slope_results, echo = FALSE, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}

pers_pred_results <- data.frame(model = c("Mean Model", "", "Dispersion Model", ""),
                                 type = c("Rpm", "CVm", "Rp_var", "CV_var"),
                                Est. = c(mean(Rp_mu), mean(CV_mu), mean(Rp_var), mean(CV_var)),
                                L.CI= c(quantile(Rp_mu,0.025), quantile(CV_mu,0.025), quantile(Rp_var,0.025),quantile(CV_var,0.025)), 
                                       U.CI= c(quantile(Rp_mu,0.975), quantile(CV_mu,0.975), quantile(Rp_var,0.975),quantile(CV_var,0.975)))

flextable::flextable(pers_pred_results) %>% 
flextable::compose(part = "header", j = c(1:5), value = c(as_paragraph("Model"),
																													as_paragraph("Estimate Type"),
																													as_paragraph("Mean Estimate"),
																																as_paragraph("95% CI", as_sub("lower")),
																																as_paragraph("95% CI", as_sub("upper")) )) %>%
flextable::compose(part = "body", i = c(1:4), j = 2, value = c(as_paragraph("Rp", as_sub("m")),
																																as_paragraph("CV", as_sub("m")),
																																as_paragraph("Rp", as_sub("v")),
																																as_paragraph("CV", as_sub("v")) )) %>%	
			align(align = "center", part = "header") %>%  fit_to_width(max_width = 7) 

```

### Associations between Personality, Plasticity, and Predictability {.tabset .tabset-fade .tabset-pills}

```{r pers_plas_pred, include=TRUE, results = "hide", message=FALSE, warning=FALSE, class.source='klippy'}
# PERSONALITY-PLASTICITY ASSOCIATIONS
# Equation 8: correlation between intercept and slope deviations
brms_cor_ID1_m0_ID1_m2 <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "cor_id__Intercept__age.Z", fixed = TRUE)[,1]

mean(brms_cor_ID1_m0_ID1_m2)
mean(stanproc_personality_plasticity_dhglm_aggression$cor_ID1_m0_ID1_m2)

# Equation 9: correlation between intercept differences and slope magnitudes   
      # Extract blups
       blups_IDm0 <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "r_id[[1-9].*,Intercept]")
       blups_IDm2 <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "r_id[[1-9].*,age.Z]")
       B_m2 <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "b_age.Z", fixed = TRUE)[,1]
      
      # Calculate the absolute magnitude of individuals slope and each individuals slope deviation (Eqn. 9 of main manuscript)
        abs_slope <- apply(blups_IDm2, 2, function(x) abs(B_m2 + x))
      
      # Using absolute slope and the individual deviations for each individuals intercept calculate the correlation across the 248 fish for each posterior sample of individual blups
        cor_ID1_m0_ID1_slope <- cor_calc(slopes = abs_slope, intercepts = blups_IDm0)
    
         mean(cor_ID1_m0_ID1_slope)
         mean(stanproc_personality_plasticity_dhglm_aggression$personality_plasticity_association1)

# PERSONALITY-PREDICTABILITY ASSOCIATIONS
# Equation 22: sign-reversed correlation between mean and dispersion intercepts
brms_personality_predictability_association <- -1*brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "cor_id__Intercept__sigma_Intercept", fixed = TRUE)[,1]
mean(brms_personality_predictability_association)
mean(stanproc_personality_plasticity_dhglm_aggression$personality_predictability_association1)

#PLASTICITY-PREDICTABILITY ASSOCIATIONS
    #Equation 23: correlation between intercepts pulled from the model
brms_cor_ID1_m2_ID1_v0 <- brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "cor_id__age.Z__sigma_Intercept", fixed = TRUE)[,1]
# note that a positive correlation indicates *less* predictability, because a greater V0 = more variance
mean(brms_cor_ID1_m2_ID1_v0)
mean(stanproc_personality_plasticity_dhglm_aggression$cor_ID1_m2_ID1_v0)

# Equation 24: slope magnitudes and sign-reversed predictability differences
blups_IDv0_reversed <- -1*brms::posterior_samples(brms_personality_plasticity_dhglm_aggression, pars = "r_id__sigma[[1-9].*,Intercept]")
brms_plasticity_predictability_association <-  cor_calc(abs_slope, blups_IDv0_reversed)
mean(brms_plasticity_predictability_association)
mean(stanproc_personality_plasticity_dhglm_aggression$plasticity_predictability_association1)
```

## Bi-variate Personality (SHGLM - Two Traits) {.tabset .tabset-fade .tabset-pills}
### Model {.tabset .tabset-fade .tabset-pills}

In this section we briefly show readers how they can fit a bi-variate model with aggression and activity, estimating intercepts within and among the traits at the individual-level. The principles for calculating repeatability and the coefficient of variation are the same as that outlined in [Personality (SHGLM)](#personality-shglm ).

```{r, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
############# Bi-variate Personality ##############################################
#stan_bivar_shglm_activity_aggression <- stan(file = "./Code/stancode_bivar_shglm.stan",
#                                             data = standata_bivar_shglm_activity_aggression,
#                                             pars = save_pars, 
#                                             iter = 6000, warmup = 2000, chains = 3, cores = 3)
##################################################################################

rerun5 = FALSE 

	if(rerun5){
			
			# Note that the random effect notation: (1 | q |...) is needed to define whether you want to estimate correlations. Random effects with the same letter (i.e., "q") will indicate that one wished to model the correlation between Y1 and Y2 id. If you change letters so that are different it will not model the correlation. It is also one way to reduce how many parameters are estimated. 
			
			formula_bivar_shglm_aggression <- bf(aggression ~ sex + age.Z + (1 | q | id))
			formula_bivar_shglm_activity <- bf(activity ~ sex + age.Z + (1 | q | id))
	
		brms_bivar_shglm_activity_aggression <- brm(formula_bivar_shglm_aggression + formula_bivar_shglm_activity, data = dat, 
								iter = 6000, warmup = 2000, chains = 3, cores = 3, 
								save_pars = save_pars()) 
		saveRDS(brms_bivar_shglm_activity_aggression, "./Models/brms_models/brms_bivar_shglm_activity_aggression")
	} else {
		brms_bivar_shglm_activity_aggression <- readRDS(here::here("Models/brms_models", "brms_bivar_shglm_activity_aggression"))
	}

	summary(brms_bivar_shglm_activity_aggression)
```


## Bi-variate Personality / Plasticity / Predictability (DHGLM - Two Traits) {.tabset .tabset-fade .tabset-pills}
### Model {.tabset .tabset-fade .tabset-pills}

In this section we briefly show readers how they can fit a bi-variate model with aggression and activity, estimating intercepts, slopes and correlations within and among the traits. The principles for calculating repeatability and the coefficient of variation are the same as that outlined in [Personality / Predictability (DHGLM)](#personality-predictability-dhglm).

```{r, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
######## Bi-variate Personality/Predictability/Plasticity ######################################
#stan_bivar_dhglm_activity_aggression <- stan(file = "./Code/stancode_bivar_dhglm.stan", 
#											data = 	standata_bivar_dhglm_activity_aggression, 
#											pars = save_pars, iter = 6000, warmup = 2000, chains = 3, cores = 3)
####################################################################################

	rerun6 = FALSE
		
	if(rerun6){
		# Note that the random effect notation: (1 | q |...) is needed to define whether you want to estimate correlations. Random effects with the same letter (i.e., "q") will indicate that one wished to model the correlation between Y1 and Y2 id, or say between sigma Y1 and Y2 etc. If you change letters so that are different it will not model the correlation. It is also one way to reduce how many parameters are estimated. 

		formula_bivar_dhglm_aggression <- bf(   aggression ~ sex + age.Z + (1 + age.Z | p | id),
						                  sigma ~ sex + age.Z + (1 | z | id))

		formula_bivar_dhglm_activity <- bf(   activity ~ sex + age.Z + (1 + age.Z | p | id),
						                sigma ~ sex + age.Z + (1 | z | id))

	brms_bivar_dhglm_activity_aggression <- brm(formula_bivar_dhglm_aggression + formula_bivar_dhglm_activity, data = dat, 
							iter = 6000, warmup = 2000, chains = 3, cores = 3, 
							save_pars = save_pars()) 
	saveRDS(brms_bivar_dhglm_activity_aggression, "./Models/brms_models/brms_bivar_dhglm_activity_aggression")

	} else {
		brms_bivar_dhglm_activity_aggression <- readRDS(here::here("Models/brms_models", "brms_bivar_dhglm_activity_aggression"))
	}

summary(brms_bivar_dhglm_activity_aggression)
```


### Associations between Personality, Plasticity, and Predictability {.tabset .tabset-fade .tabset-pills}

```{r pers_plas_pred, include=TRUE, results = "hide", message=FALSE, warning=FALSE, class.source='klippy'}
(brms_bivar_dhglm_activity_aggression$fit@sim$samples[[1]] %>% names())[1:40] # names of parameters

# PERSONALITY-PLASTICITY ASSOCIATIONS
# Equation 8: correlation between intercept and slope deviations
brms_cor_ID1_m0_ID1_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "cor_id__activity_Intercept__activity_age.Z", fixed = TRUE)[,1]
brms_cor_ID2_m0_ID2_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "cor_id__aggression_Intercept__aggression_age.Z", fixed = TRUE)[,1]

mean(brms_cor_ID1_m0_ID1_m2)
mean(stanproc_bivar_dhglm_activity_aggression$cor_ID1_m0_ID1_m2)

mean(brms_cor_ID2_m0_ID2_m2)
mean(stanproc_bivar_dhglm_activity_aggression$cor_ID2_m0_ID2_m2)

# Equation 9: correlation between intercept differences and slope magnitudes   
      # Extract blups
       blups_ID1_m0 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "r_id__activity[[1-9].*,Intercept]")
       blups_ID1_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "r_id__activity[[1-9].*,age.Z]")
       B1_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "b_activity_age.Z", fixed = TRUE)[,1]
       
       blups_ID2_m0 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "r_id__aggression[[1-9].*,Intercept]")
       blups_ID2_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "r_id__aggression[[1-9].*,age.Z]")
       B2_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "b_aggression_age.Z", fixed = TRUE)[,1]
      
      # Calculate the absolute magnitude of individuals slope and each individuals slope deviation (Eqn. 9 of main manuscript)
        abs_slope1 <- apply(blups_ID1_m2, 2, function(x) abs(B1_m2 + x))
        abs_slope2 <- apply(blups_ID2_m2, 2, function(x) abs(B2_m2 + x))
      
      # Using absolute slope and the individual deviations for each individuals intercept calculate the correlation across the 248 fish for each posterior sample of individual blups
        cor_ID1_m0_ID1_slope <- cor_calc(slopes = abs_slope1, intercepts = blups_ID1_m0)
        cor_ID2_m0_ID2_slope <- cor_calc(slopes = abs_slope2, intercepts = blups_ID2_m0)
    
         mean(cor_ID1_m0_ID1_slope)
         mean(stanproc_bivar_dhglm_activity_aggression$personality_plasticity_association1)
         
         mean(cor_ID2_m0_ID2_slope)
         mean(stanproc_bivar_dhglm_activity_aggression$personality_plasticity_association2)

# PERSONALITY-PREDICTABILITY ASSOCIATIONS
# Equation 22: sign-reversed correlation between mean and dispersion intercepts
brms_personality_predictability_association1 <- -1*brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "cor_id__activity_Intercept__sigma_activity_Intercept", fixed = TRUE)[,1] # parameter doesn't exist! Model formula must be wrong.
brms_personality_predictability_association2 <- -1*brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "cor_id__aggression_Intercept__sigma_aggression_Intercept", fixed = TRUE)[,1] # parameter doesn't exist! Model formula must be wrong.

mean(brms_personality_predictability_association1)
mean(stanproc_bivar_dhglm_activity_aggression$personality_predictability_association1)

mean(brms_personality_predictability_association2)
mean(stanproc_bivar_dhglm_activity_aggression$personality_predictability_association2)


#PLASTICITY-PREDICTABILITY ASSOCIATIONS
    #Equation 23: correlation between intercepts pulled from the model
brms_cor_ID1_m2_ID1_v0 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "cor_id__activity_age.Z__sigma_activity_Intercept", fixed = TRUE)[,1] # parameter doesn't exist! Model formula must be wrong.
brms_cor_ID2_m2_ID2_v0 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "cor_id__aggression_age.Z__sigma_aggression_Intercept", fixed = TRUE)[,1] # parameter doesn't exist! Model formula must be wrong.
# note that a positive correlation indicates *less* predictability, because a greater V0 = more variance
mean(brms_cor_ID1_m2_ID1_v0)
mean(stanproc_bivar_dhglm_activity_aggression$cor_ID1_m2_ID1_v0)

mean(brms_cor_ID2_m2_ID2_v0)
mean(stanproc_bivar_dhglm_activity_aggression$cor_ID2_m2_ID2_v0)

# Equation 24: slope magnitudes and sign-reversed predictability differences
blups_ID1_v0_reversed <- -1*brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "r_id__sigma_activity[[1-9].*,Intercept]")
brms_plasticity_predictability_association1 <-  cor_calc(abs_slope1, blups_ID1_v0_reversed)
mean(brms_plasticity_predictability_association1)
mean(stanproc_bivar_dhglm_activity_aggression$plasticity_predictability_association1)

blups_ID2_v0_reversed <- -1*brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "r_id__sigma_aggression[[1-9].*,Intercept]")
brms_plasticity_predictability_association2 <-  cor_calc(abs_slope2, blups_ID2_v0_reversed)
mean(brms_plasticity_predictability_association2)
mean(stanproc_bivar_dhglm_activity_aggression$plasticity_predictability_association2)
```

### Personality, Plasticity, and Predictability Syndromes {.tabset .tabset-fade .tabset-pills}

Between-trait correlations in individual differences in mean intercepts, slopes, and dispersion intercepts  

```{r sydromes, include=TRUE, results = "hide", message=FALSE, warning=FALSE, class.source='klippy'}
# Equation 14: Behavioural Syndromes
brms_cor_ID1_m0_ID2_m0 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "cor_id__aggression_Intercept__activity_Intercept", fixed = TRUE)[,1]
mean(brms_cor_ID1_m0_ID2_m0)
mean(stanproc_bivar_dhglm_activity_aggression$cor_ID1_m0_ID2_m0)

# Equation 15: Plasticity syndromes, slope differences
brms_cor_ID1_m2_ID2_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "cor_id__aggression_age.Z__activity_age.Z", fixed = TRUE)[,1]
mean(brms_cor_ID1_m2_ID2_m2)
mean(stanproc_bivar_dhglm_activity_aggression$cor_ID1_m2_ID2_m2)

# Equation 16: Plasticity syndromes, slope magnitudes
      # Extract blups
       blups_ID1_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "r_id__aggression[[1-9].*,age.Z]")
       blups_ID2_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "r_id__activity[[1-9].*,age.Z]")
       #population slopes
       B1_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "b_aggression_age.Z", fixed = TRUE)[,1]
       B2_m2 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "b_activity_age.Z", fixed = TRUE)[,1]
      
      # Calculate the absolute magnitude of individuals slope and each individuals slope deviation (Eqn. 9 of main manuscript)
        abs_slope1 <- apply(blups_ID1_m2, 2, function(x) abs(B1_m2 + x))
        abs_slope2 <- apply(blups_ID2_m2, 2, function(x) abs(B2_m2 + x))
      
      # Using absolute slope and the individual deviations for each individuals intercept calculate the correlation across the 248 fish for each posterior sample of individual blups
        cor_slope_mag <- cor_calc(abs_slope1, intercepts = abs_slope2)
        
        mean(cor_slope_mag)
        mean(stanproc_bivar_dhglm_activity_aggression$plasticity_syndrome)
        
# Equation 31: Predictability syndrome
brms_cor_ID1_v0_ID2_v0 <- brms::posterior_samples(brms_bivar_dhglm_activity_aggression, pars = "cor_id__sigma_aggression_Intercept__sigma_activity_Intercept", fixed = TRUE)[,1]
mean(brms_cor_ID1_v0_ID2_v0)
mean(stanproc_bivar_dhglm_activity_aggression$cor_ID1_v0_ID2_v0)
```
