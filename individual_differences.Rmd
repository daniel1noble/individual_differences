---
title: "Unifying individual differences in personality, predictability, and plasticity: a practical guide - 'brms' model code"
author: Rose E. Oâ€™Dea, Daniel W.A. Noble, Shinichi Nakagawa
date: "`r Sys.Date()`"
output: 
  bookdown::html_document2:
    code_folding: hide
    number_sections: no
    toc: yes
    toc_depth: 6
    toc_float: yes
editor_options: 
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, tidy = TRUE)
options(digits=2)
```

```{r klippy, echo=FALSE, include=TRUE, message=FALSE, warning=FALSE}
#install.packages("devtools")
remotes::install_github("rlesur/klippy")
klippy::klippy(tooltip_message = 'Click to Copy Code', tooltip_success = 'Done', position = 'right', color = "red")
```
# Introduction
This supplement introduces readers to the `brms` coding syntax, calculations and approaches outlined in: 

Rose E. O'Dea, Daniel W.A. Noble and Shinichi Nakagawa 2021. Unifying individual differences in personality, predictability, and plasticity: a practical guide. *Methods in Ecology and Evolution*.

We do not run all the models from our worked example. Instead, we only focus on a subset of models using two traits (aggression and activity) to demonstrate how to fit the single- and double- hierachical generalised models (SHGLM and DHGLM, respectively) using the R package `brms` (which interfaces with `stan`). This includes univariate and bivariate (two trait) models. For a selection of models we also show how to: 1) Calculate repeatability and the coefficient of variation for the mean and dispersion models and 2) extract and manipulate individual BLUPs (best linear unbiased predcitors) to estimate between-individual correlations outlined in our manuscript. 

# R Packages, Data and Model Fits

Readers will  need to download the data and model fits (unless they want to rerun the models) from our [Open Science Framework (OSF) Project Site](http://doi.org/10.17605/OSF.IO/V3QAX). Once downloaded and placed in your working directory run the following code to load the datasets and R packages:

```{r loadpackages, echo = TRUE, results = "hide", messages = FALSE, class.source='klippy'}
# install.packages("pacman")
# Load Libraries and relevant data
		pacman::p_load(brms, tidyverse, coda, MCMCglmm, bayesplot, here, formatR, flextable)	

		
# Get the raw. We need this for back transformation from z-scale
		# making sure fish_ID is coded as a factor (done automatically before R v4+)
		# square-root transforming novel and predator response variables
		# z-scaling all variables
		
	  dat <- read.csv("./Data/data_predictability_worked_example.csv")
		
	  dat <- dat %>% 
	         dplyr::mutate(fish_ID = factor(fish_ID, levels = unique(fish_ID)),
		                       age.Z = scale(age_days),
		                    activity = scale(dist_m_Activity),
		                  aggression = scale(stim.dist_0_5cm_dur_Aggression),
		                       novel = scale(sqrt(stim.dist_0_10cm_dur_Novel)),     
		                    predator = scale(sqrt(stim.dist_0_10cm_dur_Predator)), 
		                      social = scale(stim.dist_0_5cm_dur_Social),
		                      id = fish_ID)	
		
```

# Load Functions 

Load in the functions that will be needed to process output from the models to derive the various estimates needed for calculating the necessary parameters:

```{r funcs, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}

  # Population-level intercept   
		func_Bp <- function(B0, B1){
		  Bp <- (2*B0 + B1)/2 # assumes 50/50 ratio for B1 (in our example = sex)
		  return(Bp)
		}

   # Total variance, equation 40. Function for summing dataframe of variance components 
		func_sum_var <- function(vars){
		  sum_var <- sapply(1:nrow(vars), function(x) sum(vars[x,], na.rm = T))
		  return(sum_var)
		}


		# Variance for fixed effects
		func_var_fixed <- function(B1, B2, data){
		  # model matrix for fixed effects
		  X <- model.matrix(~ 1 + sex + age.Z, data = data) 
    		  X1 <- X[,2]
    		  X2 <- X[,3]
		  var_fixed <- sapply(1:length(B1), function(x) var(X1*B1[x] + X2*B2[x]))
		  return(var_fixed)
		}		
		
		 # within-individual standard deviation
		 	 func_var_within <- function(Bpv, sigma_v0, var_fixed_v){
		 	   
		 	   # summed variance components
		 	   var_within_exp <- func_sum_var(vars = data.frame(sigma_v0^2, var_fixed_v))
		 	   # conversion back from log scale
		 	   var_within <- func_ln_convert(mu_ln = Bpv, sigma_ln = sqrt(var_within_exp))$mu_raw
		 	   
		 	   return(var_within)
		 	 }
		 	 
		 	  # Repeatability for the dispersion model for DHGLM    
		 	 func_Rp_var <- function(Bpv, sigma_v0, var_fixed_v, var_p){
		 	   
		 	   # sum of IDv0 and fixedV = total variance in residual variance on log-normal scale:
		 	   var_residvar_exp <- func_sum_var(vars = data.frame(sigma_v0^2, var_fixed_v))
		 	   # converting back to same scale as mean model: 
		 	   sigma_residvar <- func_ln_convert(mu_ln = Bpv, sigma_ln = sqrt(var_residvar_exp))$sigma_raw
		 	   
		 	   # variance in phenotypic variance
		 	   total_var_var <- 2*var_p^2 + 3*sigma_residvar^2
		 	   
		 	   # getting variance in individual component through the preservation of the proportionality (i.e. ratio method)
		 	   ratio <- sigma_v0^2/(var_residvar_exp)
		 	   var_ID <- sigma_residvar^2*ratio
		 	   
		 	   Rp_var <- var_ID/total_var_var
		 	   return(Rp_var)
		 	 }
		
		 	 # Convert from ln to raw scale
		 func_ln_convert <- function(mu_ln, sigma_ln){
  
        mu_raw <- exp(mu_ln + sigma_ln^2/2)
        var_raw <- (exp(sigma_ln^2)-1)*exp(2*mu_ln + sigma_ln^2)
        
        x <- data.frame(mu_raw, sigma_raw = sqrt(var_raw))
        return(x)
		 }	 
		 
		# Function takes random slopes and intercepts and calculates the between individual correlation between them and returns this correlation for each row (i.e., posterior sampling iteration). It returns a posterior distribution of the correlation. 
		 
	 cor_calc <- function(slopes, intercepts){
          cors <- c()
          for(i in 1:dim(intercepts)[1]){
                cors <- c(cors, cor(as.numeric(slopes[i,]),as.numeric(intercepts[i,])))
          }
          return(cors)
      }
      
		 	 
```
# Running *brms* SHGLM and DHLGM models {.tabset}
## Personality (SHGLM) {.tabset .tabset-fade .tabset-pills} 
### Model {.tabset .tabset-fade .tabset-pills} 
Let's start by fitting a model to the aggression data to estimate "personality".

```{r personality, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
########### Personality ##########
# EXAMPLE 1: standata_personality_shglm_aggression; replicates the following model
#  stan_personality_shglm_aggression <- stan(file = "./Code/stancode_personality_shglm.stan",
#                                          data = standata_personality_shglm_aggression,
#                                          pars = save_pars, 
#                                          iter = 6000, warmup = 2000, chains = 3, cores = 3)
##################################  

	# Fit a model for aggression that includes fixed effects of sex and z-transformed age plus a random intercept for individual ID
		rerun1 = FALSE
		
		if(rerun1) {
		        model1 <- bf(aggression ~ sex + age.Z + (1 | id))
			model1_fit <- brms::brm(model1, data = dat, 
									iter = 6000, warmup = 2000, chains = 3, cores = 3, 
									save_pars = save_pars())
			saveRDS(model1_fit, "./models/model1_fit") 
		} else {
			model1_fit <- readRDS(here("models","model1_fit"))
		}
		
		summary(model1_fit)
```

### Calculate CVm and Rpm {.tabset .tabset-fade .tabset-pills} 

```{r pers_rpm_cv, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}

# (Step 1):  Get the average intercept from fixed effects.
Bpm <- func_Bp(    B0 = brms::posterior_samples(model1_fit, pars = "Intercept")[,1], 
		               B1 = brms::posterior_samples(model1_fit, pars = "sex")[,1])

# (Step 2): Extract random intercept for ID. Numerator for eqn 34. Note these are standard deviations for between-individual differences in the mean model
		sigma_m0 <- brms::posterior_samples(model1_fit, pars = "sd_id__Intercept")[,1]
		sigma_m2 <- NA # here we have no random slope, so sigma_m = sigma_m0

# (Step 3): Extract residual standard deviation
		 sigma_e <- brms::posterior_samples(model1_fit, pars = "sigma")[,1]
		
# (Step 4): Calculate fixed effect variance
	var_fixed <- func_var_fixed(  B1 =  brms::posterior_samples(model1_fit, pars = "sex")[,1],
		                            B2 =  brms::posterior_samples(model1_fit, pars = "age.Z")[,1],
		                            data = dat) 

# (Step 5): Calculate total phenotypic variance
		total_var <- func_sum_var(vars = data.frame(sigma_m0^2, var_fixed, sigma_e^2))
		
# (Step 6): Convert back from z-scale 
		
		   mu_unscaled <- mean(dat$stim.dist_0_5cm_dur_Aggression)
		sigma_unscaled <- sd(dat$stim.dist_0_5cm_dur_Aggression)
		
		            Mu <- Bpm*sigma_unscaled + mu_unscaled
	         	 Sigma <- sqrt(total_var)*sigma_unscaled
		
    indiv_sd <- sqrt(sigma_m0^2)*sigma_unscaled

# (Step 7): Calculate CVm 
		CV_m <- indiv_sd/Mu

# (Step 8): Calculate Rpm		
		Rp_m <- sigma_m0^2/total_var

# Results
			personality_results <- data.frame( CVm = mean(CV_m),
			                                   CVm.L = HPDinterval(mcmc(CV_m))[1],
			                                   CVm.U = HPDinterval(mcmc(CV_m))[2],
			                                   	Rpm =  mean(Rp_m),
			                                   Rpm.L = 	HPDinterval(mcmc(Rp_m))[1],
			                                   Rpm.U = 	HPDinterval(mcmc(Rp_m))[2])
			flextable(personality_results)
		
		
```

## Personality / Predictability (DHGLM) {.tabset .tabset-fade .tabset-pills} 
### Model {.tabset .tabset-fade .tabset-pills} 
Let's start by fitting a model to the aggression data to estimate both "personality" (mean model) and "predictability" (dispersion model).

```{r personality_pred, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
####### Personality / Predictability ##########
# EXAMPLE 2: standata_personality_dhglm_aggression; replicates the following model
# stan_personality_dhglm_aggression <- stan(file = "./Code/stancode_personality_dhglm.stan",
#                                          data = standata_personality_dhglm_aggression,
#                                          pars = save_pars, 
#                                          iter = 6000, warmup = 2000, chains = 3, cores = 3)	
###############################################   	

	rerun2=FALSE
	
	if(rerun2){
	    model2 <- bf(aggression ~ sex + age.Z + (1 | p | id),
	    			            sigma ~ sex + age.Z + (1 | p | id))

		model2_fit <- brm(model2, data = dat, 
								iter = 6000, warmup = 2000, chains = 3, cores = 3, 
								save_pars = save_pars()) 
		
		saveRDS(model2_fit, "./models/model2_fit")
	} else {
		model2_fit <- readRDS("./models/model2_fit")
	}

	summary(model2_fit)
```

### Calculate CVm and Rpm {.tabset .tabset-fade .tabset-pills} 

Here we now have two seperate models: a mean model and a dispersion model. 

```{r personality_pred_cvm_rpm, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
#################################
# Mean and Dispersion Paramaters
#################################
 
  # (Step 1): Extract the population coefficients for mean model
		 	 B0_m <- brms::posterior_samples(model2_fit, pars = "b_Intercept")[,1]			 
		 	 B1_m <- brms::posterior_samples(model2_fit, pars = "b_sex")[,1]	
		 	 B2_m <- brms::posterior_samples(model2_fit, pars = "b_age.Z")[,1]	
	
	# (Step 2): Extract the population coefficients for dispersion model	 
		 	 B0_sd_exp <- brms::posterior_samples(model2_fit, pars = "b_sigma_Intercept")[,1]			
		 	 B1_sd_exp <- brms::posterior_samples(model2_fit, pars = "b_sigma_sex")[,1]	
		 	 B2_sd_exp <- brms::posterior_samples(model2_fit, pars = "b_sigma_age.Z")[,1]
		 	 
	# (Step 3): Extract the random ID intercept variance components for random intercept. Note that we model ln(sd) so we need to convert to variance scale by multipling by 2.
		 	  sigma_ID_m0 <- brms::posterior_samples(model2_fit, pars = "sd_id__Intercept")[,1]
		 	 sigma_ID_sd0 <- brms::posterior_samples(model2_fit, 
		 	                                         pars = "sd_id__sigma_Intercept")[,1]
		 	  sigma_ID_v0 <- 2*sigma_ID_sd0
		 	 
	# (Step 4): Calculate the fixed effect variance for the mean model (var_fixed_m) and the dispersion model (B_pv)
		 	 B_pm <- func_Bp(B0 = B0_m, B1 = B1_m)
		 	 B_pv <- 2*func_Bp(B0 = B0_sd_exp, B1 = B1_sd_exp)
		 	 
	# (Step 5): Calculate the population intercept for the mean model (var_fixed_m) and dispersion model (var_fixed_v). Note that a variance on the ln(sd) scale can be converted to a ln(var) by multipling by 4. See supplemental text.
		 	 var_fixed_m <- func_var_fixed(B1 = B1_m, B2 = B2_m, data = dat)
		 	 var_fixed_v <- 4*func_var_fixed(B1 = B1_sd_exp, B2 = B2_sd_exp, data = dat)

###################################
# Mean Model - Repeatability and CV
###################################

	  # (Step 1): Calculate average within-individual / residual variance
		 	 sigma_w <- func_var_within(        Bpv = B_pv, 
		 	                               sigma_v0 = sigma_ID_v0, 
		 	                            var_fixed_v = var_fixed_v)
		 	 
		# (Step 2): Calculate total phenotypic variance 
		 	 var_p <- func_sum_var(vars = data.frame(sigma_ID_m0^2, var_fixed_m, sigma_w^2))
		 	 
		# (Step 3): Calculate repeatability
		 	 Rp_mu <- sigma_ID_m0^2/var_p
		 	 
		# (Step 4): Convert back from z-scale to calculate CVm
		 	       mu_unscaled <- mean(dat$stim.dist_0_5cm_dur_Aggression)
		 	    sigma_unscaled <-   sd(dat$stim.dist_0_5cm_dur_Aggression)
		 	 
		 	       Mu <- B_pm*sigma_unscaled + mu_unscaled
		 	    Sigma <- sqrt(var_p)*sigma_unscaled
		 	 indiv_sd <- sigma_ID_m0*sigma_unscaled
		
		# (Step 5): Calculate CVm for mean model
		 	 CV_mu <- indiv_sd/Mu
		 	 
###################################
# Dispersion Model - Repeatability and CV
###################################
		 	
		# (Step 1): Calculate repeatability for the dispersion model
		 	Rp_var <- func_Rp_var(        Bpv = B_pv, 
		 	                         sigma_v0 = sigma_ID_v0, 
		 	                      var_fixed_v = var_fixed_v, 
		 	                            var_p = var_p)
		 	
		# (Step 2): Sum of IDv0 and fixedV = total variance in residual variance on log-normal scale
		 	   var_residvar_exp <- func_sum_var(vars = data.frame(sigma_ID_v0^2, var_fixed_v))
		 
		 	   
    # (Step 3): Converting back to same scale as mean model  
		 	   sigma_residvar <- func_ln_convert(mu_ln = B_pv, 
		 	                                     sigma_ln = sqrt(var_residvar_exp))$sigma_raw
		 	   
		# (Step 4): Getting variance in individual component through the preservation of the proportionality (i.e. ratio method)
		 	    ratio <- sigma_ID_v0^2/(var_residvar_exp)
		 	   var_ID <- sigma_residvar^2*ratio
		
	  # (Step 5): Calculate coefficient of variation 
		 	   CV_var <- sqrt(var_ID)/sigma_w^2   
```

```{r personality_pred_results, echo = FALSE, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}

pers_pred_results <- data.frame(model = c("Mean Model", "", "Dispersion Model", ""),
                                 type = c("Rpm", "CVm", "Rp_var", "CV_var"),
                                Est. = c(mean(Rp_mu), mean(CV_mu), mean(Rp_var), mean(CV_var)),
                                L.CI= c(HPDinterval(mcmc(Rp_mu))[1], HPDinterval(mcmc(CV_mu))[1], HPDinterval(mcmc(Rp_var))[1],HPDinterval(mcmc(CV_var))[1]), 
                                       U.CI= c(HPDinterval(mcmc(Rp_mu))[2], HPDinterval(mcmc(CV_mu))[2], HPDinterval(mcmc(Rp_var))[2],HPDinterval(mcmc(CV_var))[2]))
flextable(pers_pred_results)

```
## Personality / Plasticity (SHGLM - Random Slope) {.tabset .tabset-fade .tabset-pills} 
### Model {.tabset .tabset-fade .tabset-pills}

Here, using a random regression model, we can estimate a random intercept and slope along with the correlation between the intercept and slopes. The correlation between intercept and slope at the individaul level is estimated directly from the model but we can also store BLUPs (`save_pars = save_pars()`) and processes these after fitting the model to estimate the correlations described within our paper.

```{r personality_plas, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}

########### Personality / Plasticity ##############
#stan_personality_plasticity_shglm_aggression; replicates the following model
#stan_personality_plasticity_shglm_aggression <- stan(file = "./Code/stancode_personality_plasticity_shglm.stan",
#                                                     data = standata_personality_plasticity_shglm_aggression,
#                                                     pars = save_pars, 
#                                                     iter = 6000, warmup = 2000, chains = 3, cores = 3)   
###################################################
	rerun3 = FALSE

	if(rerun3){
		    model3 <- bf(  aggression ~ sex + age.Z + (1 + age.Z | p | id))

		model3_fit <- brm(model3, data = dat, 
								iter = 6000, warmup = 2000, chains = 3, cores = 3, 
								save_pars = save_pars()) 
		saveRDS(model3_fit, "./models/model3_fit")
	} else {
		model3_fit <- readRDS(here("models", "model3_fit"))
	}

	summary(model3_fit)
```
### Personality-Plasticity Association{.tabset .tabset-fade .tabset-pills}

Here, using the model we can calculate the personality-plasticity association (i.e., the correlaton between individual intercepts and *absolute* slopes).

```{r pers_plas, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
     
      # Extract blups
       blups_IDmo <- brms::posterior_samples(model3_fit, pars = "r_id[[1-9].*,Intercept]")
      blups_IDm2 <- brms::posterior_samples(model3_fit, pars = "r_id[[1-9].*,age.Z]")
             Bm2 <- brms::posterior_samples(model3_fit, pars = "b_age.Z", fixed = TRUE)
  
      # Calculate the absolute magnitude of individuals slope and each individuals slope deviation (Eqn. 9 of main manuscript)
        abs_slope <- apply(blups_IDm2, 2, function(x) abs(Bm2[,1] + x))
      
      # Using absolute slope and the individual deviations for each individuals intercept calculate the correlation across the 248 fish for each psoetrior sample of individual blups
        cors <- cor_calc(slopes = abs_slope, intercepts = blups_IDmo)
       
      # Check that we have 12,000 samples from posterior
        length(cors)
      
      # Look at distribution of correlation coefficients
        hist(cors)
      
      # Estimate the mean and 95% CI  
         mean(cors)
         HPDinterval(mcmc(cors))
            
```
## Personality / Predictability / Plasticity (DHGLM - Random Slope) {.tabset .tabset-fade .tabset-pills}
### Model {.tabset .tabset-fade .tabset-pills}
```{r, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
######## Personality/Plasticity/Predictability ###################
#stan_personality_plasticity_dhglm_aggression <- stan(file = "./Code/stancode_personality_plasticity_dhglm.stan",
#                                                     data = standata_personality_plasticity_dhglm_aggression,
#                                                     pars = save_pars, 
#                                                     iter = 6000, warmup = 2000, chains = 3, cores = 3)
##################################################################
	
	rerun4 = FALSE 

	if(rerun4){
	    	model4 <- bf(  aggression ~ sex + age.Z + (1 + age.Z | q | id) ,
	    			               sigma ~ sex + age.Z + (1 + age.Z | q | id))
	
		model4_fit <- brm(model4, data = dat, 
								iter = 6000, warmup = 2000, chains = 3, cores = 3, 
								save_pars = save_pars()) 
		saveRDS(model4_fit, "./models/model4_fit")
	} else {
		model4_fit <- readRDS("./models/model4_fit")
	}

	summary(model4_fit)
```

## Bivariate Personality (SHGLM - Two Traits) {.tabset .tabset-fade .tabset-pills}
### Model {.tabset .tabset-fade .tabset-pills}
```{r, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
############# Bivariate Personality ##############################################
#stan_bivar_shglm_activity_aggression <- stan(file = "./Code/stancode_bivar_shglm.stan",
#                                             data = standata_bivar_shglm_activity_aggression,
#                                             pars = save_pars, 
#                                             iter = 6000, warmup = 2000, chains = 3, cores = 3)
##################################################################################

rerun5 = FALSE 

	if(rerun5){
			
			# Note that the random effect notation: (1 | q |...) is needed to define whether you want to estimate correlations. Random effects with the same letter (i.e., "q") will indicate that one wished to model the correlation between Y1 and Y2 id. If you change letters so that are different it will not model the correlation. It is also one way to reduce how many parameters are estimated. 
			
			model5_agg1 <- bf(aggression ~ sex + age.Z + (1 | q | id))
			model5_act2 <- bf(  activity ~ sex + age.Z + (1 | q | id))
	
		model5_fit <- brm(model5_agg1 + model5_act2, data = dat, 
								iter = 6000, warmup = 2000, chains = 3, cores = 3, 
								save_pars = save_pars()) 
		saveRDS(model5_fit, "./models/model5_fit")
	} else {
		model5_fit <- readRDS("./models/model5_fit")
	}

	summary(model5_fit)
```
## Bivariate Personality / Plasticity /Predictability (DHGLM - Two Traits) {.tabset .tabset-fade .tabset-pills}
### Model {.tabset .tabset-fade .tabset-pills}
```{r, include=TRUE, message=FALSE, warning=FALSE, class.source='klippy'}
######## Bivariate Personality/Predictability/Plasticity ######################################
#stan_bivar_dhglm_activity_aggression <- stan(file = "./Code/stancode_bivar_dhglm.stan", 
#											data = 	standata_bivar_dhglm_activity_aggression, 
#											pars = save_pars, iter = 6000, warmup = 2000, chains = 3, cores = 3)
####################################################################################

	rerun6 = FALSE
		
	if(rerun6){
		# Note that the random effect notation: (1 | q |...) is needed to define whether you want to estimate correlations. Random effects with the same letter (i.e., "q") will indicate that one wished to model the correlation between Y1 and Y2 id, or say between sigma Y1 and Y2 etc. If you change letters so that are different it will not model the correlation. It is also one way to reduce how many parameters are estimated. 

		model6_agg1 <- bf(   aggression ~ sex + age.Z + (1 + age.Z | p | id),
						                  sigma ~ sex + age.Z + (1 | z | id))

		model6_act2 <- bf(   activity ~ sex + age.Z + (1 + age.Z | p | id),
						                sigma ~ sex + age.Z + (1 | z | id))

	model6_fit <- brm(model6_agg1 + model6_act2, data = dat, 
							iter = 6000, warmup = 2000, chains = 3, cores = 3, 
							save_pars = save_pars()) 
	saveRDS(model6_fit, "./models/model6_fit")

	} else {
		model6_fit <- readRDS("./models/model6_fit")
	}
```